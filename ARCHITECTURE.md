# Project Architecture

This document explains the architecture and structure of this Kotlin Multiplatform Compose project.

## Overview

This is a Kotlin Multiplatform (KMP) project that demonstrates how to write UI code once using Jetpack Compose and run it on multiple platforms: Desktop (JVM), Web (Wasm), iOS, and Android.

## Module Structure

### 1. `shared` Module

The shared module contains platform-independent code that can be used by all platforms.

**Location**: `/shared`

**Purpose**: Contains the core UI components and business logic.

**Key Files**:
- `App.kt`: Main Compose UI component
- `Platform.kt`: Platform abstraction interface

**Source Sets**:
- `commonMain`: Platform-independent code
- `desktopMain`: JVM-specific implementations
- `iosMain`: iOS-specific implementations
- `wasmJsMain`: Web-specific implementations

### 2. `composeApp` Module

The application module contains platform-specific entry points and configurations.

**Location**: `/composeApp`

**Purpose**: Provides the main entry point for each platform.

**Source Sets**:
- `commonMain`: Shared application code
- `desktopMain`: Desktop application entry (`Main.kt`)
- `wasmJsMain`: Web application entry (`main.kt` and `index.html`)

## Code Organization

### Shared UI Layer (`shared/src/commonMain/kotlin`)

```
com.mkpharez.kmp.shared/
├── App.kt              # Main Compose UI
└── Platform.kt         # Platform interface (expect)
```

**App.kt** contains:
- `App()`: Main composable function
- `FeatureItem()`: Reusable UI component
- `getFeatures()`: Data function

**Platform.kt** uses the `expect/actual` pattern:
- `expect fun getPlatform()`: Declaration in commonMain
- `actual fun getPlatform()`: Implementation in each platform's source set

### Platform-Specific Implementations

#### Desktop (`shared/src/desktopMain/kotlin`)
```kotlin
class JVMPlatform : Platform {
    override val name: String = "Java ${System.getProperty("java.version")}"
}
actual fun getPlatform(): Platform = JVMPlatform()
```

#### iOS (`shared/src/iosMain/kotlin`)
```kotlin
class IOSPlatform : Platform {
    override val name: String = UIDevice.currentDevice.systemName() + " " + 
                                UIDevice.currentDevice.systemVersion
}
actual fun getPlatform(): Platform = IOSPlatform()
```

#### Web (`shared/src/wasmJsMain/kotlin`)
```kotlin
class WasmPlatform : Platform {
    override val name: String = "Web with Kotlin/Wasm"
}
actual fun getPlatform(): Platform = WasmPlatform()
```

## UI Components

### Main App Composable

The `App()` composable in `shared/src/commonMain/kotlin/App.kt` demonstrates:

1. **Material 3 Theme**: Uses MaterialTheme for consistent theming
2. **State Management**: Uses `remember` and `mutableStateOf` for reactive state
3. **Layout Components**: Column, Card, LazyColumn with proper spacing
4. **Animation**: AnimatedVisibility for smooth transitions
5. **Platform Detection**: Displays the current platform using `getPlatform()`

### UI Structure

```
App
├── Column (Main container)
│   ├── Text (Title: "Kotlin Multiplatform")
│   ├── Text (Subtitle: "Compose UI Demo")
│   ├── Card (Platform info)
│   │   └── Text (Current platform)
│   ├── Button (Toggle features)
│   ├── AnimatedVisibility
│   │   └── Card
│   │       └── LazyColumn
│   │           └── FeatureItem (list items)
│   └── Text (Footer)
```

## Build Configuration

### Root Build (`build.gradle.kts`)

- Applies plugins without loading them in the root project
- Uses version catalog for dependency management

### Shared Module Build (`shared/build.gradle.kts`)

Configured targets:
- `wasmJs`: Web platform using WebAssembly
- `jvm("desktop")`: Desktop platform using JVM
- `iosX64, iosArm64, iosSimulatorArm64`: iOS platforms

Dependencies:
- Compose runtime, foundation, material3, UI
- Compose resources and UI tooling

### ComposeApp Module Build (`composeApp/build.gradle.kts`)

Similar target configuration plus:
- Desktop application configuration with native distributions
- Web browser configuration with webpack
- iOS framework generation

## Dependency Management

Uses Gradle Version Catalog (`gradle/libs.versions.toml`):

Key dependencies:
- Kotlin 2.0.0
- Compose Plugin 1.6.11
- Material 3 components
- Kotlin coroutines

## Platform Entry Points

### Desktop
```kotlin
// composeApp/src/desktopMain/kotlin/Main.kt
fun main() = application {
    Window(
        onCloseRequest = ::exitApplication,
        title = "KMP Desktop App",
    ) {
        MainApp()
    }
}
```

### Web
```kotlin
// composeApp/src/wasmJsMain/kotlin/main.kt
fun main() {
    CanvasBasedWindow(canvasElementId = "ComposeTarget") {
        MainApp()
    }
}
```

### iOS
iOS uses the framework generated by Kotlin/Native. The framework is then embedded in an Xcode project.

## Build Outputs

### Desktop
- **JAR**: `composeApp/build/libs/composeApp-desktop.jar`
- **Native packages**: `composeApp/build/compose/binaries/main/`
  - DMG (macOS)
  - MSI (Windows)
  - DEB (Linux)

### Web
- **Production build**: `composeApp/build/dist/wasmJs/productionExecutable/`
  - `composeApp.js`: Main JavaScript file
  - `index.html`: Entry HTML page

### iOS
- **Frameworks**: `composeApp/build/bin/ios*/releaseFramework/`
  - ComposeApp.framework

## Key Concepts

### 1. Expect/Actual Pattern

Allows defining platform-agnostic interfaces in common code and platform-specific implementations:

```kotlin
// commonMain
expect fun getPlatform(): Platform

// desktopMain  
actual fun getPlatform(): Platform = JVMPlatform()

// iosMain
actual fun getPlatform(): Platform = IOSPlatform()
```

### 2. Compose Multiplatform

- Write UI code once using Compose
- Compile to different platforms
- Share business logic and UI
- Platform-specific customization when needed

### 3. Source Sets

Each target has corresponding source sets:
- `commonMain`: Shared across all platforms
- `<target>Main`: Platform-specific code
- `commonTest`: Shared tests
- `<target>Test`: Platform-specific tests

## Development Workflow

1. **Write common UI**: Add composables in `shared/src/commonMain/kotlin`
2. **Platform-specific code**: Use expect/actual in respective source sets
3. **Test on desktop**: Quick iteration with `./gradlew :composeApp:run`
4. **Build for all platforms**: Use Gradle tasks or GitHub Actions
5. **Deploy**: Use generated artifacts for each platform

## Extending the App

### Adding New Features

1. Create new composables in `shared/src/commonMain/kotlin`
2. Add dependencies in version catalog if needed
3. Update respective build files
4. Test on all platforms

### Adding Platform-Specific Code

1. Define interface in `commonMain`
2. Implement in each platform's source set
3. Use in common code through the interface

### Adding New Platforms

KMP supports many platforms. To add a new one:
1. Add target in `build.gradle.kts`
2. Create corresponding source set
3. Implement platform-specific code
4. Update build configuration

## Resources

- [Kotlin Multiplatform Docs](https://kotlinlang.org/docs/multiplatform.html)
- [Compose Multiplatform](https://github.com/JetBrains/compose-multiplatform)
- [Gradle Version Catalogs](https://docs.gradle.org/current/userguide/platforms.html)
